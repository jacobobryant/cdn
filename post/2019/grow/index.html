<html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1" name="viewport" /><link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet" /><link href="/css/custom.css" rel="stylesheet" /><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" /><link href="/css/prism.css" rel="stylesheet" /><title>Growing a Framework, or, Clojure Made Easy | Jacob O'Bryant</title><meta content="Jacob O&apos;Bryant" name="author" /><meta content="Growing a Framework, or, Clojure Made Easy | Jacob O&apos;Bryant | Jacob O&apos;Bryant" name="description" /></head><body style="margin-bottom:20px;font-size:16px;font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif"><nav class="navbar navbar-dark bg-dark navbar-expand-md"><div class="container"><ul class="navbar-nav"><li class="nav-item"><a class="navbar-brand" href="https://jacobobryant.com/" style="font-size:22px">Jacob O'Bryant</a></li><li class="nav-item active"><a class="nav-link" href="https://jacobobryant.com/" style="font-size:18px">Articles</a></li><li class="nav-item "><a class="nav-link" href="https://jacobobryant.com/recommendations/" style="font-size:18px">Recommendations</a></li><li class="nav-item "><a class="nav-link" href="https://jacobobryant.com/about/" style="font-size:18px">About</a></li></ul></div></nav><div style="width:25px;height:25px"></div><div class="container"><div class="row"><div class="col-lg-2 d-flex flex-row flex-lg-column align-items-center align-items-lg-start mb-3" style="font-size:14px"><img src="/about/avatar.jpg" width="130px" /><div style="width:20px;height:10px"></div><div><div>Founder @ <a href="https://lagukan.com" target="_blank">Lagukan</a></div><div style="width:5px;height:5px"></div><div><a href="https://tinyletter.com/jacobobryant" target="_blank">Subscribe</a> (<a href="https://jacobobryant.com/atom.xml" target="_blank">feed</a>)</div><div style="width:5px;height:5px"></div><div><a href="https://twitter.com/obryant666" target="_blank">Twitter</a></div></div></div><div class="col-lg" style="max-width:600px"><h3>Growing a Framework, or, Clojure Made Easy</h3><p>June 2019</p><p><em>Note: I wrote this with a Clojure audience in mind, but I think it applies more generally. It uses the terms "simple" and "easy" <a href="https://www.infoq.com/presentations/Simple-Made-Easy/#presentationNotes">as defined by Rich Hickey</a> (see "Key Takeaways" in that link). Also, "complect" means "make more complex" or "intertwine," i.e. to combine multiple things that should be separate.</em></p><p>We all know that the Clojure community prefers libraries over frameworks.[1] The difference between a library and a framework isn't well-defined, but I think of it this way: a framework is just a library with a much larger scope than the average library. This has several implications:</p><ul><li><p>Frameworks have an inversion-of-control feeling: instead of plugging a bunch of libraries into your code, you plug your code into the framework. (Some people give this as the defining quality of a framework, but I think it's just a side effect).</p></li><li><p>Frameworks are more likely to need modification to handle your particular use case.</p></li></ul><p>The latter point is why we don't like frameworks. The effort required to patch a framework to accommodate the functionality you want is often higher than the effort to put all the libraries together yourself. The downside is that now you have to put all the libraries together yourself, which can be tedious.</p><p>What's really going on here is that frameworks are more likely to be complected. You could think of a library as a single, decomplected building block ("do one thing and do it well"). Frameworks attempt to do the work of putting the building blocks together in a reusable way, which is a good thing! We need that if we're going to keep building higher-level abstractions. But in the process, frameworks often complect the building blocks, making it unnecessarily difficult to build on top of them.</p><p>There can be a danger of dismissing efforts to assemble building blocks altogether because "that feels like a framework, and frameworks are bad." But frameworks aren't inherently bad. For emphasis, let me restate this another way. Simplifying is the process of breaking complex things into building blocks which can then be put together in many different ways. "Easifying" is just the next step: once you have the right building blocks, you make bigger building blocks out of them. Libraries are simple, frameworks are easy. Frameworks can be good if they're both simple and easy.[2]</p><p>So how do you make big building blocks that stay simple? For a general treatment of this question, I'd highly recommend the classic <a href="https://www.cs.virginia.edu/~evans/cs655/readings/steele.pdf">Growing a Language</a> which I just reread.[3] In this particular situation, my answer is "I'm not sure, but I have a few ideas currently and I'm going to keep thinking about it as I go." My "few ideas currently" are:</p><ul><li><p>"Library-driven development." I think it's good to have a library where you can conveniently move code to as you're working on applications. That's what <a href="https://github.com/jacobobryant/trident">Trident</a> is for me. I try to move as much non-application-specific code as I can into Trident. Even if some of the code never gets used outside the application I originally wrote it for, 1) it's hard to know which code will and won't be useful later, 2) it makes my applications much more layered, with the top layers—the ones that are actually in the application's project—much easier to hold in your head.</p></li><li><p>Lots of little libraries. I keep Trident's code not just in one git repo but also in a single <code>src</code> directory. I then define in a config file how the code should be split up into artifacts. The result is that it's extremely convenient for me to split the code up into little libraries/artifacts that can be used independently. The libraries are mostly divided based on their external dependencies, so you should hopefully be able to use whatever slice of Trident you want without taking in a bunch of irrelevant dependencies.</p></li><li><p>Solve real problems, not hypothetical ones. I'm not going out of my way to try to solve a bunch of problems for other people in advance. I'm just trying to make sure that the solutions I create for problems I have can be reused. No one should have to solve a problem that I've already solved. Part of that includes writing good documentation, which I've attempted.</p></li></ul><p>There's a fourth point which needs more explaining first. Think of an artifact as a DAG of its dependencies. And I mean "artifact" in an abstract sense; not only jars but also individual functions. Imagine an artifact A that has dependencies on B, C, D and E:</p><pre><code>  A
 / \
B   C
 \ / \
  D   E
</code></pre><p>Now suppose you want only a slice of A's functionality. If everything you want is contained in C, D and E, the problem is easy: just use C.</p><pre><code>  C
 / \
D   E
</code></pre><p>But what if you do want A, but you just want to tweak some of the functionality in a lower artifact, like D or E? The author of A needs to somehow write their code in a way so that the lower layers can be modified. It's a hard problem since you often have a lot of dependencies and it's hard to know ahead of time in what ways they'll need to be modified.</p><p>Armin Ronacher wrote a great article related to this problem called <a href="http://lucumr.pocoo.org/2013/2/13/moar-classes/">"Start Writing More Classes"</a>. Of particular importance is this footnote at the end:</p><blockquote><p>Something else I want to mention: what's written above will most likely result in some sort of warmed up discussion in regards to object oriented programming versus something else. Or inheritance versus strategies. Or virtual methods versus method passing. Or whatever else hackernews finds worthy of a discussion this time around.</p><p>All of that is entirely irrelevant to the point I'm making which is that monolithic pieces of code are a bad idea. And our solution to monolithic code in Python are classes. If your hammer of choice is Haskell then use whatever the equivalent in Haskell looks like. Just don't force me to fork your library because you decided a layered API is not something you want to expose to your user.</p></blockquote><p>So this is my fourth point:</p><ul><li>Figure out the best ways to use Clojure's language constructs to provide layered APIs. For example, although I know <em>how</em> to use types and protocols, I don't yet grok <em>when</em> to introduce my own. I'm planning to keep thinking about things like this as I go.</li></ul><p>So that's my philosophy. Hope you liked it!</p><p><br ><br ><br ></p><p><a href="https://news.ycombinator.com/item?id=20164657">Hacker News</a></p><p><a href="https://www.reddit.com/r/Clojure/comments/bzrkay/growing_a_framework_or_clojure_made_easy/">Reddit</a></p><p><strong>Notes</strong></p><p>[1] Here's an explanation of why from <a href="http://lucumr.pocoo.org/2010/6/14/opening-the-flask/#why-create-your-own-framework">outside Clojureland</a>, and there's also <a href="https://clojureverse.org/t/clojure-libs-frameworks-tooling-for-rapid-web-development/4017/5">this message</a> by Sean Corfield. I want to be clear that I agree with these arguments; I'm just attempting to bring the discussion a little deeper.</p><p>[2] Although we probably wouldn't call them "frameworks" then, in the same way that AI stops being called AI once it actually works.</p><p>Also, I'm reminded of <a href="https://blog.appcanary.com/2017/hard-isnt-simple-ruby-clojure.html">this blog post</a>. I think the author hit on some good points, although I don't agree with all his conclusions, like this one:</p><blockquote><p>In practice, ‘Simple Made Easy’ is an elaborate excuse for making software that is hard to use.</p></blockquote><p>You have to make things simple before you make things easy, and a lot of work in Clojure has gone towards making things simple. If less work has gone into making things easy, I think a more likely explanation is that people don't have infinite time, and they've tried to spend the time they do have on the most important things.</p><p>However, we can't forget that making things easy is an important next step, which is the point I'm trying to make.</p><p>[3] I'm fascinated that this problem seems to repeat itself.</p><hr /><p class="small">There's more where that came from if you <a href="https://tinyletter.com/jacobobryant" target="_blank">subscribe</a> to my newsletter.</p></div></div></div><script type="text/javascript">
var sc_project=12140644;
var sc_invisible=1;
var sc_security="e36ded0c";
var sc_https=1;
var sc_remove_link=1;
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><img class="statcounter"
src="https://c.statcounter.com/12140644/0/e36ded0c/1/"
alt="site stats"></div></noscript><script src="/js/prism.js"></script></body></html>