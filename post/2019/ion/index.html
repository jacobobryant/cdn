<html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1" name="viewport" /><link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet" /><link href="/css/custom.css" rel="stylesheet" /><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" /><link href="/css/prism.css" rel="stylesheet" /><title>Building a CRUD app with Datomic Cloud Ions | Jacob O'Bryant</title><meta content="Jacob O&apos;Bryant" name="author" /><meta content="Building a CRUD app with Datomic Cloud Ions | Jacob O&apos;Bryant | Jacob O&apos;Bryant" name="description" /></head><body style="margin-bottom:20px;font-size:16px;font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif"><nav class="navbar navbar-dark bg-dark navbar-expand-md"><div class="container"><ul class="navbar-nav"><li class="nav-item"><a class="navbar-brand" href="https://jacobobryant.com/" style="font-size:22px">Jacob O'Bryant</a></li><li class="nav-item active"><a class="nav-link" href="https://jacobobryant.com/" style="font-size:18px">Articles</a></li><li class="nav-item "><a class="nav-link" href="https://jacobobryant.com/recommendations/" style="font-size:18px">Recommendations</a></li><li class="nav-item "><a class="nav-link" href="https://jacobobryant.com/about/" style="font-size:18px">About</a></li></ul></div></nav><div style="width:25px;height:25px"></div><div class="container"><div class="row"><div class="col-lg-2 d-flex flex-row flex-lg-column align-items-center align-items-lg-start mb-3" style="font-size:14px"><img src="/about/avatar.jpg" width="130px" /><div style="width:20px;height:10px"></div><div><div>Founder @ <a href="https://lagukan.com" target="_blank">Lagukan</a></div><div style="width:5px;height:5px"></div><div><a href="https://tinyletter.com/jacobobryant" target="_blank">Subscribe</a> (<a href="https://jacobobryant.com/atom.xml" target="_blank">feed</a>)</div><div style="width:5px;height:5px"></div><div><a href="https://twitter.com/obryant666" target="_blank">Twitter</a></div></div></div><div class="col-lg" style="max-width:600px"><h3>Building a CRUD app with Datomic Cloud Ions</h3><p>May 2019</p><p><em>Update: published <a href="https://github.com/jacobobryant/flexbudget">source code</a>.</em></p><p>I just released <a href="https://notjust.us">FlexBudget</a>, the website version of a script I wrote several months ago to handle our budgeting needs.[1] I built it using <a href="https://docs.datomic.com/cloud/ions/ions.html">Datomic Cloud ions</a>. I started using Datomic On-Prem sometime last year, but this was my first time using Datomic Cloud (let alone ions).[2]</p><p>I think Clojure + Datomic opens the doors for some great innovations in web application architecture (e.g. the ideas discussed in <a href="https://tonsky.me/blog/the-web-after-tomorrow/">this classic</a>), not to mention that Datomic alone has spoiled me and I don't know if I could ever go back to SQL now. But even with ions, I think there's still a lot of work left to be done on Clojure's web dev story. What follows is a description of my experience in setting up FlexBudget.</p><p><em>Note: This post assumes you are already familiar with Clojure and Datomic.</em></p><p><strong>Routing</strong></p><p>I ended up using a mono-Lambda that forwarded all requests to the same ion, then that ion used Compojure to route the request to the appropriate handler. For local development, I just ran a local web server with that handler.</p><pre><code class="lang-clojure">(def handler&apos;
  (-&gt; routes
      ; various middleware
      wrap-catchall))

(def handler (ionize handler&apos;))

(defn start-immutant []
  (imm/run handler&apos; {:port 8080}))
</code></pre><p>(I started out using Aleph, but I was getting a weird bug where it wasn't passing requests to my handler. I'm not sure what was going on there, but things started working again when I used Immutant. I also tried Jetty, but it had dependency conflicts with Datomic Cloud.)</p><p>This worked great for my little project, though maybe in the future I'll need to stop using a mono-Lambda.</p><p><span id="transaction-functions"><strong>Transaction Functions</strong></span></p><p>This was more complicated. To use a custom transaction function, it has to be deployed. You can't tell the transactor (which runs in the cloud) to somehow use a local transaction function that's only defined on your laptop. The <a href="https://docs.datomic.com/cloud/operation/planning.html#transaction-functions">official advice</a> is:</p><blockquote><p>Transaction functions are pure functions, so you do not need to deploy them anywhere for testing. You can simply invoke them as ordinary code in your REPL or test suite.</p></blockquote><p>I think that leaves a little to be desired, though. I also want to actually use my website while I'm developing it. I need my site, running on localhost, to be able to send requests to my ions, also running on localhost, and then have those ions run transaction functions that are only defined on my laptop (i.e. haven't been deployed yet).</p><p>So, I wrote a function <code>eval-tx-fns</code> which takes a transaction function and applies it locally. Then the "plain" transaction can be sent to the transactor.</p><pre><code class="lang-clojure">(def transact (if (:local-tx-fns? config)
                (let [lock (Object.)]
                  (fn [conn arg-map]
                    (locking lock
                      (-&gt;&gt; #(u/eval-tx-fns (d/with-db conn) %)
                           (update arg-map :tx-data)
                           (d/transact conn)))))
                d/transact))
</code></pre><p>Out of laziness, I created this <code>transact</code> function and used that whenever I needed to transact something. I also had to write a similar replacement function for <code>with</code>. It would probably be cleaner to create my own implementation of the Datomic client protocol as is done <a href="https://github.com/ComputeSoftware/datomic-client-memdb/blob/master/src/compute/datomic_client_memdb/core.clj#L90">here</a>.</p><p>The <code>locking</code> call is used to make sure that transactions stay serialized. This works only because during dev, all transactions to the dev database I'm using go through a single machine (my laptop). And being a single developer using the Solo topology, that's fine. However, it could be an issue for a production system with <a href="https://docs.datomic.com/cloud/operation/planning.html#stages">query groups for different stages</a>.</p><p>The staging query group can only use transaction functions that have been deployed to the primary group. If we update a transaction function and want staging to run the updated version before it gets deployed to the primary group, we'll have to apply the transaction locally in the manner I just described. If the staging query group is limited to one instance, then we can keep the transactions serialized by using <code>locking</code> as we did before. Otherwise, we'd have to add some kind of external lock to ensure that only one instance is executing transaction functions at a time.</p><p>This strategy may lower transaction throughput, but that's probably acceptable for dev stages. An alternate solution would be running a separate production topology for each stage, but I'm guessing that would be more expensive.[3]</p><p><strong>Deployment</strong></p><p>I wrote <a href="https://gist.github.com/jacobobryant/9c13f4cd692ff69d8f87b0d872aeb64e">this Planck script</a> in order to automate the steps of "push, deploy, run the deploy status command until it succeeds or fails".</p><p>I had some troubles with my deploys failing, even after I resolved dependency conflicts and tested locally. The problem was always that I had some piece of initialization code that started running as soon as the code was loaded. This caused the deploy to hang and timeout. (Specifically, the <code>ValidateService</code> step would hang, like in <a href="https://forum.datomic.com/t/ion-deployment-failure/683">this question</a>).</p><p>For example, you shouldn't load configuration with <code>datomic.ion/get-params</code> until a request comes in. You can memoize the retrieval like so:</p><pre><code class="lang-clojure">(def get-params
  (memoize
    (fn [env]
      (-&gt; {:path (str &quot;/datomic-shared/&quot; env &quot;/bud/&quot;)}
          ion/get-params keywordize-keys))))
</code></pre><p>And then <em>don't call it until you have to</em>. I used Firebase for authentication, and it requires some initialization code that fetched a secret from <code>get-params</code>:</p><pre><code class="lang-clojure">(let [options ...] ; includes a call to get-params
  (FirebaseApp/initializeApp options))
</code></pre><p>One of my deployment failures was happening because I had the Firebase init code running immediately. Deployment worked again after I wrapped it in an <code>init-firebase!</code> function which I then called only when verifying tokens:</p><pre><code class="lang-clojure">(defn verify-token [token]
  (when (= 0 (count (FirebaseApp/getApps)))
    (init-firebase!))
  ...)
</code></pre><p>I also wrapped my calls to <code>d/client</code> and <code>d/conn</code> in memoized functions like in the <a href="https://github.com/Datomic/ion-starter/blob/master/src/datomic/ion/starter.clj#L13">ion starter project</a>, but I found that they didn't get redefined when I ran <code>clojure.tools.namespace.repl/refresh</code>. So I instead defined them as mount states:</p><pre><code class="lang-clojure">(mount.core/defstate client :start
  (d/client (:client-cfg config)))
</code></pre><p>And then I added some ring middleware to start mount on the first request:</p><pre><code class="lang-clojure">(defn wrap-start-mount [handler]
  (fn [req]
    (when (contains? #{mount.core.NotStartedState
                       mount.core.DerefableState}
                     (type client))
      (mount.core/start))
    (handler req)))
</code></pre><p><strong>Interlude</strong></p><p>Throw in some logs with <code>datomic.ion.cast</code> and that about covers my experiences directly with Datomic Cloud ions. It took a while to figure things out, but I'm happy with it now, even though the transaction function thing seems a little hacky (I'm not sure what else to do about that).</p><p>The rest of this post is about the way I set up the frontend/backend interaction.</p><p><strong>DataScript</strong></p><p>I recently wrote a <a href="https://github.com/jacobobryant/clue">Clue web app</a> that used a single atom for storing frontend state (with Datomic on the backend). Board games tend to have complicated data models, and I definitely felt the impedance mismatch pains of having to project my Datomic data onto a hierarchical atom. So with this project (even though the data model here is much simpler right now), I definitely wanted to use DataScript.</p><p>After the user logs in, the frontend hits an <code>/init</code> endpoint which returns their datoms:</p><pre><code class="lang-clojure">(defn datoms-for [db uid]
  (let [user-eid (:db/id (d/pull db [:db/id] [:user/uid uid]))]
    (-&gt;&gt;
      (conj
        (vec (d/q &apos;[:find ?e ?attr ?v :in $ ?user :where
                    [?ent :auth/owner ?user]
                    (or
                      [(identity ?ent) ?e]
                      [?ent :entry/asset ?e])
                    [?e ?a ?v]
                    [?a :db/ident ?attr]]
                  db user-eid))
        [user-eid :user/uid uid])
      (u/stringify-eids ds-schema))))
</code></pre><p>Basically, <code>datoms-for</code> looks for values of <code>:auth/owner</code> that correspond to the current user. I'm not using any DB filters, but a better approach might be to do that and then allow the frontend to send an arbitrary query.</p><p>The datoms also go through a <code>stringify-eids</code> function that I wrote. This function takes e.g. <code>[[1 :foo 2] [3 :some/ref 1]]</code> and turns it into <code>[[&quot;1&quot; :foo 2] [&quot;3&quot; :some/ref &quot;1&quot;]]</code>. That way, DataScript will treat the entity IDs as temporary, and new IDs will be assigned. This is important because Datomic entity IDs can be larger than JavaScript's <code>Number.MAX_SAFE_INTEGER</code>. So instead of using Datomic's entity IDs on the frontend, I let DataScript assign its own IDs and then maintain a mapping between DataScript's IDs and Datomic's IDs (which are stored on the frontend as strings).</p><p>To be exact, they're actually stored as tagged literals, e.g. <code>#eid &quot;123456789&quot;</code>. I'll get to this later, but this allows the frontend to send a transaction like <code>[[#eid &quot;12345789&quot; :bar &quot;hello&quot;]]</code> to the backend, and then I simply include an entry for <code>eid</code> in my <code>data_readers.clj</code> file.</p><p>I'm also passing a <code>ds-schema</code> ("DataScript schema") argument to <code>stringify-eids</code>. This comes from a library that I share between the frontend and backend:</p><pre><code class="lang-clojure">(def schema
  {:user/uid [:db.type/string :db.unique/identity]
   :user/email [:db.type/string :db.unique/identity]
   :auth/owner [:db.type/ref]
   :entry/date [:db.type/instant]
   :entry/draft [:db.type/boolean]
   ; etc
   ]})

(def datomic-schema (u/datomic-schema schema))
(def ds-schema (u/datascript-schema schema))
</code></pre><p><strong>Materialized views</strong></p><p>I've never actually used re-frame much. Although I'm using DataScript instead of a normal atom for storing frontend state, there is <a href="https://github.com/denistakeda/re-posh">re-posh</a> which combines re-frame with <a href="https://github.com/mpdairy/posh">Posh</a>, a library that lets you define reactive DataScript queries. I've used Posh a little bit, but</p><ol><li>It breaks on some <a href="https://github.com/mpdairy/posh/issues/26">edge cases</a>, including a case that I ran into myself.</li><li>You can't use <code>pull</code> inside of queries.</li></ol><p>So instead I wrote a macro <code>defq</code>:</p><pre><code class="lang-clojure">(defq entries
  (-&gt;&gt; @conn
       (d/q &apos;[:find [(pull ?e [*]) ...] :where
              (or [?e :entry/draft]
                  [?e :entry/date])])))
</code></pre><p><code>defq</code> takes some arbitrary code and stores it in a function. It creates a reactive atom (<code>entries</code> in this case) and populates it with the results of the function. Whenever I run a transaction, the function is ran again (and the atom is repopulated with the results).</p><p>Obviously this won't be fast when you have lots of queries, but it's good enough for now. I'll revisit it later.</p><p>Besides <code>defq</code>, I've found that using plain old <code>reagent.ratom/reaction</code> is nice and succinct:</p><pre><code class="lang-clojure">(def entry (reaction (last @entries)))
(def draft? (reaction (:entry/draft @entry)))
</code></pre><p>I store all of these in a single namespace, so I can reference them from my Reagent views with e.g. <code>@db/entries</code> or <code>@db/draft?</code>.</p><p><strong>Components</strong></p><p>I've been mainly using <a href="https://re-com.day8.com.au/#/introduction">re-com</a> and it's really nice. I had two minor annoyances though. First, all of the parameters are defined with map destructuring. This means that when you use container elements, you have to write <code>[rc/h-box :children [foo bar baz]]</code> instead of just <code>[rc/h-box foo bar baz]</code>. Containers are used pretty often and having all these <code>:children</code> can add up.</p><p>That's not too bad though, I simply defined my own <code>h-box</code> and <code>v-box</code> components that didn't use map destructuring.</p><p>The other thing I ran into was when I used the <code>horizontal-tabs</code> component and I wasn't able to change the colors using inline styles; I had to include a separate css file to override the Bootstrap styles.</p><p>Going forward it'd be nice to have everything be fully customizable with inline styles, so I'll need to decide if I want to keep using re-com and/or Bootstrap and make some modifications or if I should roll my own. I'll admit that I'm not much of a UI person, but it would be nice to figure out a system that works for me (and makes it easy for me to make websites that look nice. I guess there are people who care about that).</p><p><strong>Transactions on the frontend</strong></p><p>On the frontend I also defined a custom <code>transact!</code> function:</p><pre><code class="lang-clojure">(defn transact! [persist-fn conn tx &amp; queries]
  (let [tx-result (d/transact! conn tx)]
    (apply invalidate! queries)
    (go (let [tx (u/translate-eids (:schema @conn) (::eids @conn) tx)
              eids (&lt;! (persist-fn tx))
              tempids (reverse-tempids tx-result eids)]
          (swap! conn update ::eids merge tempids)))
    tx-result))
</code></pre><p>It does several things:</p><ol><li><p>It applies the transaction to the frontend database immediately. Currently I don't have anything in place to rollback if the transaction fails on the backend; that's part of my future work.</p></li><li><p><code>invalidate!</code> is what updates the queries that I defined earlier with <code>defq</code>.</p></li><li><p><code>translate-eids</code> traverses the transaction, replacing DataScript's entity IDs with the tagged-literal Datomic IDs like I mentioned before. For example, given a transaction of <code>[[:db/add 1 :foo &quot;bar&quot;]]</code> and an entity ID mapping of <code>{1 #eid &quot;12345&quot;}</code>, the return value would be <code>[[:db/add #eid &quot;12345&quot; :foo &quot;bar&quot;]]</code> (surprise). Unfortunately we can't do something simple with <code>clojure.walk/postwalk</code> like "if an element is a key in the entity ID map, replace it with the value" because we don't know if the number is actually an entity ID or just a number. The only way to know is to traverse the transaction according to the <a href="https://docs.datomic.com/cloud/transactions/transaction-data-reference.html#orgb749e75">grammar</a> and replace entity IDs along the way. It was a little tedious to write but not super complicated.</p></li><li><p><code>persist-fn</code> takes the transaction and sends it to the backend. The backend returns the entity IDs of any newly created entities. For example, if you transacted <code>[[:db/add &quot;tmp-id&quot; :foo &quot;bar&quot;]]</code> and the new entity ID assigned by Datomic was 12345, the backend (and thus <code>persist-fn</code>) would return <code>{&quot;tmp-id&quot; #eid &quot;12345&quot;}</code>.</p></li><li><p><code>reverse-tempids</code> will use that return value to map the entity IDs assigned by DataScript to the ones assigned by Datomic. Continuing the previous example, if DataScript assigned an entity ID of 4, then the return value of <code>reverse-tempids</code> would be <code>{4 #eid &quot;12345&quot;}</code>.</p></li></ol><p><strong>Transactions on the backend</strong></p><p>This is one of the nicest parts of the architecture in my opinion. I've set things up so that the frontend can send arbitrary transactions and the backend will analyze them to find out if the current user is authorized to make them. That way I didn't have to code up a new endpoint for each kind of edit the user can make.</p><p>I set up a single endpoint, <code>/tx</code>, to receive transactions. Upon receipt, it first makes sure the transaction doesn't include any transaction functions that haven't been whitelisted. Then we run the transaction through a transaction function called <code>authorize</code>. This function speculatively runs the transaction using <code>d/with</code>. Then it analyzes the result to find out which entities were affected.</p><p>Each entity that was changed must pass an app-specific authorizer function. Here's an example of an authorizer function; it will allow a user to create a message entity as long as they are listed as the sender of that message:</p><pre><code class="lang-clojure">(s/def ::message (u/ent-spec :req [:message/text :message/sender]))

(def authorizers
  {[nil ::message]
  (fn [{:keys [uid eid datoms db-before db-after before after]}]
    (not-empty
      (d/q &apos;[:find ?e :in $ ?e ?user :where
             [?e :message/sender ?user]]
        db-after eid [:user/uid uid])))})
</code></pre><p>I'll dissect this now:</p><ul><li><p><code>ent-spec</code> is basically a custom version of <code>s/keys</code> that works with Datomic entities. Also, keys are only allowed if they are listed in either <code>:req</code> or <code>:opt</code>. the frontend can't attach an attribute to an entity unless we give them explicit permission to do so.</p></li><li><p>The keys in <code>authorizers</code> are a pair of specs. The first spec defines what type the entity had before running the transaction, and the second spec defines what type it had after. I call this the entity's "signature." <code>nil</code> means that the entity didn't exist. So in this case, we're saying that this function only applies to newly created <code>::message</code> entities.</p></li><li><p>For each entity in the transaction, <code>authorize</code> will look for an authorizer function that has a matching signature. If it finds one, it'll pass the entity along with some other information to the function. If the function returns truthy, then the change is authorized. If there aren't any matching authorizer functions that return truthy, then the change is unauthorized and <code>authorize</code> will throw an exception.</p></li></ul><p>The authorizer function receives an argument that includes the following keys:</p><ul><li><p><code>uid</code>: the ID of the authenticated user. In my case, this is an ID assigned by Firebase Authentication.</p></li><li><p><code>eid</code>: an entity ID from the result of the current transaction.</p></li><li><p><code>datoms</code>: the subset of datoms added or retracted by the current transaction that apply to <code>eid</code>.</p></li><li><p><code>db-before</code> and <code>db-after</code>: these are taken from the transaction result.</p></li><li><p><code>before</code> and <code>after</code>: these are the result of <code>(d/pull db &apos;[*] eid)</code> with <code>db-before</code> and <code>db-after</code>, respectively (or <code>nil</code> if the entity didn't exist).</p></li></ul><p>So, if you provide the specs and the authorizer functions, then <code>authorize</code> can take care of the rest. It separates the logic of what changes are allowed from how those changes are delivered to the backend; so for the latter we can say "send them all to the same place, and send them in whatever form you want."</p><p><strong>Future work</strong></p><p>One of the key takeaways here is that the vast majority of my time was not spent focusing on just the application logic. Eric Normand has described the need for a <a href="https://lispcast.com/clojure-needs-grow-boring-web-framework-boring-data-science/">"boring web framework."</a> I think it's a good analysis. As far as I can tell, Clojure has had solid adoption among <a href="https://en.wikipedia.org/wiki/Technology_adoption_life_cycle">innovators and early adopters</a>. You can do some cool things if you take the time to set it up yourself, and this is more-or-less fine for people who already know Clojure. But if we automate this process, Clojure will have a much better chance at <a href="https://en.wikipedia.org/wiki/Crossing_the_Chasm">crossing the chasm</a> into the early majority.[4]</p><p>As I've built FlexBudget, I've tried to keep as many things separated into libraries as possible. My plan is to continue this process and try to create a web framework that allows even Clojure beginners to get up and running with a Clojure + Datomic stack that has all these architectural components I've described. I'm also going to add more components like realtime communications. Especially if/when <a href="https://www.reddit.com/r/Clojure/comments/b46vl1/reactive_datalog_for_datomic/">reactive Datalog becomes available</a>, I think this framework could be a great boon for web app development.</p><br>
<br>
<br><p><a href="https://vectorified.com/ru-ion">Russian translation</a></p><p><strong>Notes</strong></p><p>[1] I think most approaches to budgeting, e.g. zero-sum budgeting, force you to go into too much detail. When I'm monitoring resource usage, I don't care exactly how the resource is being used—I just want a high level "is it OK or is it not OK." If there's a problem, then I'll use a profiler/disk usage analyzer/etc to dig deeper. I use FlexBudget to give me the high-level "is it OK," but it's not meant as a profiler.</p><p>[2] Before I actually read the documentation for ions, I thought they were just some kind of hack to let you define transaction functions in Cloud. For anyone who doesn't already know, they're actually much more than that. They allow you to reuse the Datomic Cloud infrastructure for deploying your application, so you don't have to deal with setting up your own infrastructure. It's a big step towards the Holy Grail of only having to think about your application logic.</p><p>Given that, I'm much more ok with the >= $30/month price tag of Datomic Cloud. I used to think it was too much just for a side project that isn't making any money, but now I'm fine with it because of the time it saves me. Or rather, the time it will save me now that I know how to use it.</p><p>[3] I was about to talk about the possibility of Cognitect making it so each query group could have its own transactor, but then I realized that would simply reduce to running separate production topologies. So I'm doubtful if there are any possible solutions that are better than what I've described.</p><p>[4] In respect to the "libraries vs. frameworks" debate: the problem with frameworks isn't that they do a lot for you, it's that they're hard to change if you want something different. With enough care, we could make a library/framework that sets up a lot of defaults for you but still allows you to customize it however you need.</p><hr /><p class="small">There's more where that came from if you <a href="https://tinyletter.com/jacobobryant" target="_blank">subscribe</a> to my newsletter.</p></div></div></div><script type="text/javascript">
 var sc_project=12140644;
 var sc_invisible=1;
 var sc_security="e36ded0c";
 var sc_https=1;
 var sc_remove_link=1;
 </script>
 <script type="text/javascript"
 src="https://www.statcounter.com/counter/counter.js"
 async></script>
 <noscript><div class="statcounter"><img class="statcounter"
 src="https://c.statcounter.com/12140644/0/e36ded0c/1/"
 alt="site stats"></div></noscript><script src="/js/prism.js"></script></body></html>